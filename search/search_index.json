{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"What is <code>SableDb</code>?","text":"<p><code>SableDb</code> is a key-value NoSQL database that utilizes <code>RocksDb</code> as its storage engine and is compatible with the Redis protocol. It aims to reduce memory costs and increase capacity compared to Redis. <code>SableDb</code> features include Redis-compatible access via  any Redis client, up to 64K databases support, asynchronous replication using transaction log tailing and TLS connectivity support.</p>"},{"location":"design/data-encoding/","title":"Overview","text":"<p><code>SableDb</code> uses a Key / Value database for its underlying data storage. We chose to use <code>RocksDb</code>  as its mature, maintained and widely used in the industry by giant companies.</p> <p>Because the <code>RocksDb</code> is key-value storage and Redis data structures can be more complex, an additional  data encoding is required.</p> <p>This chapter covers how <code>SableDb</code> encodes the data for the various data types (e.g. <code>String</code>, <code>Hash</code>, <code>Set</code> etc)</p> <p>Note</p> <p>Numbers are encoded using Big Endians to preserve lexicographic ordering</p>"},{"location":"design/data-encoding/#the-string-data-type","title":"The <code>String</code> data type","text":"<p>The most basic data type in <code>SableDb</code> is the <code>String</code> data type. <code>String</code>s in <code>SableDb</code> are always binary safe Each <code>String</code> record in the <code>SableDb</code> consists of a single entry in <code>RocksDb</code>:</p> <pre><code>   A    B      C      D                E        F       G     H\n+-----+-----+-------+----------+    +-----+------------+----+-------+\n| 1u8 | DB# | Slot# | user key | =&gt; | 0u8 | Expirtaion | ID | value |\n+-----+-----+-------+----------+    +-----+------------+----+-------+\n</code></pre> <p>The key for a <code>String</code> record is encoded as follows:</p> <ul> <li><code>A</code> the first byte ( <code>u8</code> ) is always set to <code>1</code> - this indicates that this is a data entry (there are other type of keys in the database)</li> <li><code>B</code> the database ID is encoded as <code>u16</code> (this implies that <code>SableDb</code> supports up to <code>64K</code> databases)</li> <li><code>C</code> the slot number</li> <li><code>D</code> the actual key value (e.g. <code>set mykey myvalue</code>  -&gt; <code>mykey</code> is set here)</li> </ul> <p>The value is encoded as follows:</p> <ul> <li><code>E</code> the first byte is the type bit, value of <code>0</code> means that the this record is of type <code>String</code></li> <li><code>F</code> the record expiration info</li> <li><code>G</code> unique ID (relevant for complex types like <code>Hash</code>), for <code>String</code> this is always <code>0</code></li> <li><code>H</code> the user value</li> </ul> <p>Using the above encoding, we can now understand how <code>SableDb</code> reads from the database. Lets have a look a the command:</p> <pre><code>get mykey\n</code></pre> <p><code>SableDb</code> encodes a key from the user key (<code>mykey</code>) by prepending the following:</p> <ul> <li><code>1</code>u8 - to indicate that this is the data record</li> <li>The active database number (defaults to <code>0</code>)</li> <li>The slot number</li> <li>The user string key (i.e. <code>mykey</code>)</li> </ul> <p>This is the key that is passed to <code>RocksDb</code> for reading - If the key exists in the database:     - If the type (field <code>E</code>) is <code>!= 0</code> - i.e. the entry is not a <code>String</code>, <code>SableDb</code> returns a <code>-WRONGTYPE</code> error     - If value is expired -&gt; <code>SableDb</code> returns <code>null</code> and deletes the record from the database     - Otherwise, <code>SableDb</code> returns the <code>H</code> part of the value (the actual user data) - Else (no such key) return <code>null</code></p>"},{"location":"design/data-encoding/#the-list-data-type","title":"The <code>List</code> data type","text":"<p>A <code>List</code> is a composite data type. <code>SableDb</code> stores the metadata of the list using a dedicated record and each list element is stored in a separate entry.</p> <pre><code>List metadata:\n\n   A    B       C        D            \n+-----+---- +--------+------------+ \n| 1u8 | DB# |  Slot# |  list name |  \n+-----+---- +--------+------------+    \n                             E        F        G        H      I       J\n                        +-----+------------+--------- +------+------+-------+\n                   =&gt;   | 1u8 | Expirtaion | List UID | head | tail |  size |\n                        +-----+------------+--------- +------+------+-------+\n\nList item:\n\n   K        L              M                 N      O           P\n+-----+--------------+---------------+    +------+--------+------------+\n| 2u8 | List ID(u64) |  Item ID(u64) | =&gt; | Left | Right  |     value  |\n+-----+--------------+---------------+    +------+--------+------------+\n</code></pre> <p>Unlike <code>String</code>, a <code>List</code> is using an additional entry in the database that holds the list metadata.</p> <ul> <li>Encoded items <code>A</code> -&gt; <code>D</code> are the same as <code>String</code></li> <li><code>E</code> the first byte is always set to <code>1</code> (unlike <code>String</code> which is set to <code>0</code>)</li> <li><code>F</code> Expiration info</li> <li><code>G</code> The list UID. Each list is assigned with a unique ID (an incremental number that never repeat itself, evern after restarts)</li> <li><code>H</code> the UID of the list head item (<code>u64</code>)</li> <li><code>I</code> the UID of the list tail item (<code>u64</code>)</li> <li><code>J</code> the list length</li> </ul> <p>In addition to the list metadata (<code>SableDb</code> keepts a single metadata item per list) we add a list item per new list item using the following encoding:</p> <ul> <li><code>K</code> the first bit which is always set to <code>2</code> (\"List Item\")</li> <li><code>L</code> the parent list ID (see field <code>G</code> above)</li> <li><code>M</code> the item UID</li> <li><code>N</code> the UID of the previous item in the list ( <code>0</code> means that this item is the head)</li> <li><code>O</code> the UID of the next item in the list ( <code>0</code> means that this item is the last item)</li> <li><code>P</code> the list value</li> </ul> <p>The above encoding allows <code>SableDb</code> to iterate over all list items by creating a <code>RocksDb</code> iterator and move it to  the prefix <code>[ 2 | &lt;list-id&gt;]</code> (<code>2</code> indicates that only list items should be scanned, and <code>list-id</code> makes sure that only the requested list items are visited)</p>"},{"location":"design/overview/","title":"High Level Design","text":""},{"location":"design/overview/#overview","title":"Overview","text":"<p>This chapter covers the overall design choices made when building <code>SableDb</code>.</p> <p>The networking layer of SableDb uses a lock free design. i.e. once a connection is assigned to a worker thread it does not interact with any other threads or shared data structures.</p> <p>Having said that, there is one obvious \"point\" that requires locking: the storage.  The current implementation of <code>SableDb</code> uses <code>RocksDb</code> as its storage engine  (but it can, in principal, work with other storage engines like <code>Sled</code>), even though the the storage itself is thread-safe, <code>SableDb</code> still needs to provide atomicity for multiple database access (consider the <code>ValKey</code>'s <code>getset</code> command which requires to perform both <code>get</code> and <code>set</code> in a single operation) - <code>SableDb</code> achieves this by using a shard locking (more details on this later).</p> <p>By default, <code>SableDb</code> listens on port <code>6379</code> for incoming connections. A newly arrived connection is then assigned to a worker thread (using simple round-robin method). The worker thread spawns a local task  (A task, is tokio's implementation for green threads) which performs the TLS handshake (if dictated by the configuration) and then splits the connection stream into two: </p> <ul> <li>Reader end</li> <li>Writer end</li> </ul> <p>Each end of the stream is then passed into a newly spawned local task for handling</p> <p>Below is a diagram shows the main components within <code>SableDb</code>:</p> <p></p>"},{"location":"design/overview/#acceptor-thread","title":"Acceptor thread","text":"<p>The main thread of <code>SableDb</code> - after spawning the worker threads - is used as the TCP acceptor thread. Unless specified otherwise, <code>SableDb</code> listens on port 6379. Every incoming connection is moved to a thread for later handling so the acceptor can accept new connections</p>"},{"location":"design/overview/#tls-handshake","title":"TLS handshake","text":"<p>The worker thread moves the newly incoming connection to a task which does the following:</p> <ul> <li>If TLS is enabled by configuration, performs the TLS handshake (asynchronously) and split the connection into two (receiver and writer ends)</li> <li>If TLS is not needed, it just splits the connection into two (receiver and writer ends)</li> </ul> <p>The TLS handshake task spawns the reader and writer tasks and moves two proper ends of the connection to each of the task. A tokio channel is then established between the two tasks for passing data from the reader -&gt; writer task</p>"},{"location":"design/overview/#the-reader-task","title":"The reader task","text":"<p>The reader task is responsible for:</p> <ul> <li>Reading bytes from the stream</li> <li>Parsing the incoming message and constructing a <code>RedisCommand</code> structure</li> <li>Once a full command is read from the socket, it is moved to the writer task for processing</li> </ul>"},{"location":"design/overview/#the-writer-task","title":"The writer task","text":"<p>The writer task input are the commands read and constructed by the reader task.</p> <p>Once a command is received, the writer task invokes the proper handler for that command (if the command it not supported an error message is sent back to the client). </p> <p>The command handler, can return one of 2 possible actions:</p>"},{"location":"design/overview/#send-a-response-to-the-client","title":"Send a response to the client","text":"<p>There are 2 ways that the writer task can send back a response to the client:</p> <ul> <li>The command handler returns the complete response (e.g. <code>+OK\\r\\n</code>)</li> <li>The command handler writes the response directly to the socket</li> </ul> <p>The decision whether to reply directly or propagate the response to the caller task is done on per command basis. The idea is to prevent huge memory spikes where possible.</p> <p>For example, the <code>hgetall</code> command might generate a huge output (depends on the number of fields in the hash and their size) so it is probably better to write the response directly to the socket (using a controlled fixed chunks) rather than building  a complete response in memory (which can take Gigabytes of RAM) and only then write it to the client.</p>"},{"location":"design/overview/#block-the-client","title":"Block the client","text":"<p>When a client executes a blocking call on a resource that is not yet available, the writer task is suspended until:</p> <ul> <li>Timeout occurrs (most blocking commands allow to specify timeout duration)</li> <li>The resource is available</li> </ul>"},{"location":"design/replication/","title":"Replication","text":""},{"location":"design/replication/#overview","title":"Overview","text":"<p><code>SableDb</code> supports a <code>1</code> : <code>N</code> replication (single primary -&gt; multiple replicas) configuration.</p>"},{"location":"design/replication/#replication-client-server-model","title":"Replication Client / Server model","text":"<p>On startup, <code>SableDb</code> spawns a thread (internally called <code>Relicator</code>) which is listening on the main port + <code>1000</code>. So if, for example, the server is configured to listen on port <code>6379</code>, the replication port is set to <code>7379</code></p> <p>For every new incoming replication client, a new thread is spawned and served. thread-safe</p> <p>The replication is done using the following methodology:</p> <ol> <li>The replica is requesting from the primary a set of changes starting from a given ID</li> <li>If the primary is able to locate the requested change ID, it builds a \"change request message\" and sends it over to the client (the ID accepted from the client is the starting ID for the change request)</li> <li>Steps 1-2 are repeated indefinitely</li> <li>If the primary is unable to locate the requested change ID, it replies with a \"Negative ack\" to the client</li> <li>The client sends a \"Full Sync\" request to the server</li> <li>The primary creates a checkpoint from the database and sends it over to the replica + it sends the last change committed to the checkpoint (this will be the \"Next ID\" to fetch)</li> <li>From hereon, steps 1-2 are repeated</li> </ol> <p>Note</p> <p>Its worth mentioning that the primary server is stateless i.e. it does not keep track of its replicas. It is up to the  replica server to pull data from the primary and to keep track of the next change sequence ID to pull.</p> <p>Note</p> <p>In case there are no changes to send to the replica, the primary delays the response until something is available</p> <p>Internally, <code>SableDb</code> utilizes <code>RocksDb</code> APIs: <code>create_checkpoint</code> and <code>get_updates_since</code></p> <p>In addition to the above APIs, <code>SableDb</code> maintains a file named <code>changes.seq</code> inside the database folder of the replica server which holds the next transaction ID that should be pulled from the primary.</p> <p>In any case of error, the replica switches to <code>FULLSYNC</code> request.</p> <p>The below sequence of events describes the data flow between the replica and the primary:</p> <p></p> <p>When a <code>FULLSYNC</code> is needed, the flow changes to this:</p> <p></p>"},{"location":"design/replication/#replication-client","title":"Replication client","text":"<p>In addition to the above, the replication instance of <code>SableDb</code> is running in <code>read-only</code> mode. i.e. it does not allow execution of any command marked as <code>Write</code></p>"}]}