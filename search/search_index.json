{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"What is <code>SableDb</code>?","text":"<p><code>SableDb</code> is a key-value NoSQL database that utilizes <code>RocksDb</code> as its storage engine and is compatible with the Redis protocol. It aims to reduce memory costs and increase capacity compared to Redis. <code>SableDb</code> features include Redis-compatible access via  any Redis client, up to 64K databases support, asynchronous replication using transaction log tailing and TLS connectivity support.</p>"},{"location":"design/overview/","title":"High Level Design","text":""},{"location":"design/overview/#overview","title":"Overview","text":"<p>This chapter covers the overall design choices made when building <code>SableDb</code>.</p> <p>The networking layer of SableDb uses a lock free design. i.e. once a connection is assigned to a worker thread it does not interact with any other threads or shared data structures.</p> <p>Having said that, there is one obvious \"point\" that requires locking: the storage.  The current implementation of <code>SableDb</code> uses <code>RocksDb</code> as its storage engine  (but it can, in principal, work with other storage engines like <code>Sled</code>), even though the the storage itself is thread-safe, <code>SableDb</code> still needs to provide atomicity for multiple database access (consider the <code>ValKey</code>'s <code>getset</code> command which requires to perform both <code>get</code> and <code>set</code> in a single operation) - <code>SableDb</code> achieves this by using a shard locking (more details on this later).</p> <p>By default, <code>SableDb</code> listens on port <code>6379</code> for incoming connections. A newly arrived connection is then assigned to a worker thread (using simple round-robin method). The worker thread spawns a local task  (A task, is tokio's implementation for green threads) which performs the TLS handshake (if dictated by the configuration) and then splits the connection stream into two: </p> <ul> <li>Reader end</li> <li>Writer end</li> </ul> <p>Each end of the stream is then passed into a newly spawned local task for handling</p> <p>Below is a diagram shows the main components within <code>SableDb</code>:</p> <p></p>"},{"location":"design/overview/#acceptor-thread","title":"Acceptor thread","text":"<p>The main thread of <code>SableDb</code> - after spawning the worker threads - is used as the TCP acceptor thread. Unless specified otherwise, <code>SableDb</code> listens on port 6379. Every incoming connection is moved to a thread for later handling so the acceptor can accept new connections</p>"},{"location":"design/overview/#tls-handshake","title":"TLS handshake","text":"<p>The worker thread moves the newly incoming connection to a task which does the following:</p> <ul> <li>If TLS is enabled by configuration, performs the TLS handshake (asynchronously) and split the connection into two (receiver and writer ends)</li> <li>If TLS is not needed, it just splits the connection into two (receiver and writer ends)</li> </ul> <p>The TLS handshake task spawns the reader and writer tasks and moves two proper ends of the connection to each of the task. A tokio channel is then established between the two tasks for passing data from the reader -&gt; writer task</p>"},{"location":"design/overview/#the-reader-task","title":"The reader task","text":"<p>The reader task is responsible for:</p> <ul> <li>Reading bytes from the stream</li> <li>Parsing the incoming message and constructing a <code>RedisCommand</code> structure</li> <li>Once a full command is read from the socket, it is moved to the writer task for processing</li> </ul>"},{"location":"design/overview/#the-writer-task","title":"The writer task","text":"<p>The writer task input are the commands read and constructed by the reader task.</p> <p>Once a command is received, the writer task invokes the proper handler for that command (if the command it not supported an error message is sent back to the client). </p> <p>The command handler, can return one of 2 possible actions:</p>"},{"location":"design/overview/#send-a-response-to-the-client","title":"Send a response to the client","text":"<p>There are 2 ways that the writer task can send back a response to the client:</p> <ul> <li>The command handler returns the complete response (e.g. <code>+OK\\r\\n</code>)</li> <li>The command handler writes the response directly to the socket</li> </ul> <p>The decision whether to reply directly or propagate the response to the caller task is done on per command basis. The idea is to prevent huge memory spikes where possible.</p> <p>For example, the <code>hgetall</code> command might generate a huge output (depends on the number of fields in the hash and their size) so it is probably better to write the response directly to the socket (using a controlled fixed chunks) rather than building  a complete response in memory (which can take Gigabytes of RAM) and only then write it to the client.</p>"},{"location":"design/overview/#block-the-client","title":"Block the client","text":"<p>When a client executes a blocking call on a resource that is not yet available, the writer task is suspended until:</p> <ul> <li>Timeout occurrs (most blocking commands allow to specify timeout duration)</li> <li>The resource is available</li> </ul>"},{"location":"design/replication/","title":"Replication","text":""},{"location":"design/replication/#overview","title":"Overview","text":"<p><code>SableDb</code> supports a <code>1</code> : <code>N</code> replication (single primary -&gt; multiple replicas) configuration.</p>"},{"location":"design/replication/#replication-client-server-model","title":"Replication Client / Server model","text":"<p>On startup, <code>SableDb</code> spawns a thread (internally called <code>Relicator</code>) which is listening on the main port + <code>1000</code>. So if, for example, the server is configured to listen on port <code>6379</code>, the replication port is set to <code>7379</code></p> <p>For every new incoming replication client, a new thread is spawned and served. thread-safe</p> <p>The replication is done using the following methodology:</p> <ol> <li>The replica is requesting from the primary a set of changes starting from a given ID</li> <li>If the primary is able to locate the requested change ID, it builds a \"change request message\" and sends it over to the client (the ID accepted from the client is the starting ID for the change request)</li> <li>Steps 1-2 are repeated indefinitely</li> <li>If the primary is unable to locate the requested change ID, it replies with a \"Negative ack\" to the client</li> <li>The client sends a \"Full Sync\" request to the server</li> <li>The primary creates a checkpoint from the database and sends it over to the replica + it sends the last change committed to the checkpoint (this will be the \"Next ID\" to fetch)</li> <li>From hereon, steps 1-2 are repeated</li> </ol> <p>Note</p> <p>Its worth mentioning that the primary server is stateless i.e. it does not keep track of its replicas. It is up to the  replica server to pull data from the primary and to keep track of the next change sequence ID to pull.</p> <p>Note</p> <p>In case there are no changes to send to the replica, the primary delays the response until something is available</p> <p>Internally, <code>SableDb</code> utilizes <code>RocksDb</code> APIs: <code>create_checkpoint</code> and <code>get_updates_since</code></p> <p>In addition to the above APIs, <code>SableDb</code> maintains a file named <code>changes.seq</code> inside the database folder of the replica server which holds the next transaction ID that should be pulled from the primary.</p> <p>In any case of error, the replica switches to <code>FULLSYNC</code> request.</p> <p>The below sequence of events describes the data flow between the replica and the primary:</p> <p></p> <p>When a <code>FULLSYNC</code> is needed, the flow changes to this:</p> <p></p>"},{"location":"design/replication/#replication-client","title":"Replication client","text":"<p>In addition to the above, the replication instance of <code>SableDb</code> is running in <code>read-only</code> mode. i.e. it does not allow execution of any command marked as <code>Write</code></p>"}]}